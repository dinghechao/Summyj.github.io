<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用字符串数组实现一个简单的文本编辑器基础]]></title>
    <url>%2F2017%2F08%2F24%2F%E5%88%A9%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[功能： 接受多行输入，输入空行退出。并将输入的所有内容打印在屏幕上。 代码： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#define STRNUM 100#define STRLEN 100char text[STRNUM][STRLEN];int main()&#123; int line,strnum,Strlen; printf("tips: enter a spaceline to exit\n"); printf("---------------------------------\n"); //receive for (line=0; line &lt; STRNUM; line++) &#123; printf("line%d: ", line); gets_s(text[line]); if (!*text[line]) &#123; break; &#125; &#125; //printf for (strnum = 0; strnum &lt; line; strnum++) &#123; for (Strlen = 0; text[strnum][Strlen]; Strlen++) &#123; putchar(text[strnum][Strlen]); &#125; putchar('\n'); &#125; system("pause"); return 0;&#125; 效果：]]></content>
      <categories>
        <category>C/C++基础</category>
      </categories>
      <tags>
        <tag>字符串数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用arp.sh脚本文件抓取局域网内所有主机的IP和MAC地址]]></title>
    <url>%2F2017%2F08%2F17%2F%E7%94%A8arp-sh%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E6%8A%93%E5%8F%96%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E6%89%80%E6%9C%89%E4%B8%BB%E6%9C%BA%E7%9A%84IP%E5%92%8CMAC%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[本篇博文主要介绍以下内容： 1. ARP协议简介 2. 小程序：抓取局域网内所有主机的IP和MAC地址 ARP协议 Concept先来一波文字(oﾟ▽ﾟ)o ： 在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号。却不知道目的主机的硬件地址（MAC地址）,而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。 因此在通讯前必须获得目的主机的MAC地址，ARP协议就起到这个作用 它的工作步骤如下： Step1：源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”,并将这个请求广播到本地网段(以太⽹网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播) Step2：目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符；则发送一个ARP应答数据包给源主机,将⾃己的硬件地址填写在应答包中。 注：每台主机都维护一个ARP缓存表,可以用arp -a命令查看： 为了降低对内存的占用，缓存表中的表项都有过期时间(一 般为20分钟)，如果20分钟内没有再次使用某个表项，则该表项失效。下次还要发ARP请求来获得目的主机的硬件地址。 所以ARP协议的作用就是在局域网内实现从IP地址到MAC地址的转换 ARP报文格式ARP数据报的格式如下所示: 图中： 源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现⼀次，对于链路层为以太网的情况是多余的。但如果链路层是其它类型的网络则有可能是必要的。 硬件类型指链路层网络类型，1为以太网。协议类型指要转换的地址类型，0x0800为IP地址。后面两个地址长度对于以太网地址和IP地址分别为6和4(字节)。 op字段为1表示ARP请求,op字段 2表示ARP应答。 在ARP协议实际工作中，先关心OP字段是APR请求1还是应答2，然后是目的IP地址/发送端IP地址。最后发送前边的数据报。 #Code ## 下面编写脚本文件arp.sh实现对局域网内所有主机IP和MAC地址的抓取。 Step1：touch arp.sh脚本文件，用vim编辑完成后，更改权限至可执行文件 Step2：编辑源程序 以下为源程序： 注：里边的ip_head是博主虚拟机的所在局域网的网络号，读者想要抓取，就要更改其为自己所在局域网的ip地址，在命令行输入ifconfig命令就可以看到： Step3：sh arp.sh运行程序抓取到了局域网内所有应答成功主机的IP和MAC地址 运行程序： 得到以下结果： 其中，2是博主手机的ip和MAC地址： 这个在手机设置里的关于手机现象就可以看到。 1是博主电脑的ip和MAC地址： 这个在wimdows里打开cmd窗口输入“ipconfig /all”命令就可以看到： Expand： tcpdump&amp;nmap 其实，上边的方法是有很大弊端的，现在网络加密技术发达，简单的抓包的方法已经不能满足网络分析的需求，基于此，Linux提供了抓包工具tcpdump和namp。 1.tcpdump1. What？ tcpdump是一个用于截取网络分组，并输出分组内容的工具。 tcpdump凭借强大的功能和灵活的截取策略，使其成为类UNIX系统下用于网络分析和问题排查的首选工具。它提供了源代码，公开了接口，因此具备很强的可扩展性，对于网络维护和入侵者都是非常有用的工具。 在命令行输入tcpdump -h就可以查看它的基本语法： 上边显示了各种选项的含义。 tcpdump存在于基本的Linux系统中，由于它需要将网络界面设置为混杂模式，普通用户不能正常执行，但具备root权限的用户可以直接执行它来获取网络上的信息。因此系统中存在网络分析工具主要不是对本机安全的威胁，而是对网络上的其他计算机的安全存在威胁。 2.How？博主对tcpdump没有深入的了解，也没有找到优秀的文章讲解，感兴趣的小伙伴可以自行百度٩(๑&gt;◡&lt;๑)۶ 2.nmapwhat &amp; how这个工具是需要下载的，想了解的小伙伴可以自己百度。。 Other 虚拟机联网的四种方式 博主刚开始运行程序的时候并没有成功，是因为没有把虚拟机的联网方式改为桥接模式，这样虚拟机会共享其所在电脑主机的ip地址。所以不能抓取，解决方法就是把联网方式改为桥接模式： 打开虚拟机的设置界面，在网络适配选项选中桥接模式。完成后重启虚拟机再运行程序就不会有问题了 事实上，虚拟机的联网方式常用的是就是图中前两种形式，主要看你的上网环境。 如果你是外网环境，建议你使用NAT模式，此时虚拟机和客户机共享ip地址上网。就出现了抓取不到的问题。如果你是局域网环境建议使用桥接，就是第二种模式，该模式下虚拟机和你局域网中的其他实体计算机在网络状态上完全一样，你完全可以把他当作是局域网中的另一台实体计算机。 至于剩下的两种就不怎么常用了，读者有兴趣的话可以自己找资料查下，网上有很多。 外网和内网 至于桥接模式和NAT模式所涉及的外网和内网的概念，博主也找到了一篇不错的文章了解了一下，感兴趣的小伙伴请戳这里： 关于内网和外网区别]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>IP</tag>
        <tag>ARP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秒懂UDP协议&TCP协议]]></title>
    <url>%2F2017%2F08%2F17%2F%E5%B0%8F%E7%99%BD%E7%9A%84%E7%A6%8F%E9%9F%B3%E2%80%94%E7%A7%92%E6%87%82UDP%E5%8D%8F%E8%AE%AE-TCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[本文介绍了UDP\TCP协议的基础知识，主要内容有： UDP\TCP协议在TCP/IP协议栈中的位置和作用 UDP\TCP协议数据段格式 TCP协议如何保证数据传输的可靠性 TCP/IP协议栈 TCP/IP⽹网络协议栈分为应⽤用层(Application)、传输层(Transport)、⽹网络层(Network)和链路层 (Link)四层： 其中，传输层及其以下的机制由内核提供，应用层由用户进程提供。 应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节。从而将数据从一台计算机通过⼀定的路径发送到另一台计算机。 这就是两台计算机通过TCP/IP协议栈进行通讯的过程，当然还有很多细节。 此过程中，TCP&amp;UDP协议在传输层发挥作用。上层协议根据TCP数据段首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程，完成数据传输。 TCP协议一种面向连接的、可靠的协议。 有点像打电话。双方拿起电话互通身份之后就建立了连接，然后说话就行了。这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。 也就是说TCP传输的双方需要⾸先建立连接，之后由TCP协议保证数据收发的可靠性。丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流。通讯之后关闭连接。 UDP协议 UDP协议不面向连接，也不保证可靠性。 有点像寄信，写好信放到邮筒里。既不能保证信件在邮递过程中不会丢失，也不能保证信件是按顺序寄到目的地的。 所以，使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。 数据段格式 不同的协议层对数据包有不同的称谓，在传输层叫做段(segment)，在网络层叫做数据报(datagram)。在链路层叫做帧(frame)。 接下来详细介绍UDP和TCP协议的数据段格式。 UDP协议 举个例子，分析一帧基于UDP的TFTP协议帧： 源端口号0x05d4(1492)是客户端的端口号，目的端口号0x0045(69)是TFTP服务的well-known端口号。 UDP报长度为0x003f，即63字节。包括UDP首部和UDP层payload的长度。 UDP首部和UDP层payload的校验和为0xac40。 一般的网络通信都是像TFTP协议这样，通信的双方分别是客户端和服务器。客户端主动发起请求 (上面的例子就是客户端发起的请求帧)。而服务器被动地等待、接收和应答请求。 客户端的IP地址和端口号唯一标识了该主机上的TFTP客户端进程，服务器的IP地址和端口号唯一标识了该主机上的TFTP服务进程。 前面提过，UDP协议不⾯向连接，也不保证传输的可靠性。这一点主要体现在： 1. 无法判别数据的失败传输 发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。 2. 无法保证数据接收顺序 接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，UDP协议层也不保证按发送时的顺序交给应用层。 3. 丢包问题 通常接收端的UDP协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理，如果应用程序提取和处理的速度很慢，而发送端发送的速度很快。就会丢失数据包,UDP协议层并不报告这种错误。 因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案。 例如等待应答、超时重发、为数据包编号、流量控制等。一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。 例如，基于UDP的TFTP 协议一般只用于传送小文件，而基于tcp的协议适⽤于各种文件的传输。 TCP协议下⾯面 看TCP协议如何⽤用⾯面向连接的服务来代替应⽤用程序解决传输的可靠性问 题。 和UDP协议一样，TCP的数据段中也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。 32位序号、32位确认序号、窗口大小均是保证数据传输可靠性的机制。 4位首部长度表示TCP协议头的长度，以4字节为单位。因此TCP协议头最长可以是4x15=60字节，如果没有选项字段,TCP协议头最短20字节。 URG、ACK、PSH、RST、SYN、FIN是六个控制位，用于保证传输可靠性。 16位检验和将TCP协议头和数据都也用于保证传输可靠性。 TCP协议的可靠性 上边说过，TCP保证数据传输的可靠性，那它是怎么保证的呢？故事很长，你准备好听我说了么&lt;(▰˘◡˘▰)&gt; 1. TCP是面向连接的，并且是全双工的 事实上，TCP协议为应用层提供了全双工(full-duplex)的服务，双方都可以主动甚至同时给对方发送数据。 如果通讯过程只能采用一问一答的方式，收和发两个方向不能同时传输，在同一时间只允许一个方向的数据传输,则称为’’半双工(half-duplex)’’ 2. TCP基于请求应答机制 在数据传输时，请求方请求数据时附上自己报文序号，应答方在应答时附上确认序号，防止数据丢失。所以最新一条数据无法保证可靠性，只有确认过的消息才能保证 3. 丢包重查 基于请求应答机制，数据丢失可以及时发现，从而进行丢包重查。 4. 保证数据按序到达 同样基于请求应答机制，数据可以按时到达。 5. 6个控制位 上边TCP协议的数据段中，给出了6个控制位，它们也保证了数据传输的可靠性。具体待博主后续介绍。 6. 定时器 TCP协议维护了各种定时器，用来保证双方通信的可靠性。 比如防止过多闲置链接的“保活定时器”，还有防止接收方缓冲区虽满，但迟迟不读取数据，导致占用链接资源的“超时重查定时器”（超时后将此链接重置（关闭））。 还有很多定时器，博主将在后续博文中总结，敬请期待。 7. 流量控制 数据传输中，发送与接收速度不一致时，可以扔掉多余数据。因为有丢包重查。但多次丢包重查操作也会浪费资源。所以为了协调速度，应该以缓冲区大小为标志。每次数据传输时接收方将自己的缓冲区大小告知发送方，防止其在接收缓冲区已满的情况下再发送数据。 这就是流量控制。 TCP数据段中的——16位窗口大小就是这里的接收缓冲区大小，它也叫做滑动窗口。滑动窗口的大小永远是自己能接收数据的缓冲区大小。这样就保证了数据进可能少的丢包。 数据通讯中滑动窗口如何发挥作用，博主也会在后续博文中详细介绍。小伙伴们不要心急哟~ 8. 网络拥堵避免算法 除了滑动窗口，TCP还实现了网络拥堵避免算法，进一步避免了大量数据丢包。 至于算法是怎么样的，博主就不在这里介绍了，感兴趣的小伙伴可以自行百度ヾ(◍°∇°◍)ﾉﾞ 9. TCP是面向连接的 TCP的面向连接主要体现在3次握手、4次挥手上。这可是个很重要的问题，当然要另写博文详细介绍啦。我们再约~ 注意：虽说TCP协议与UDP协议相比，保证了数据传输的可靠性，但两者没有谁好谁坏的问题，只是适用场景不同。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>UDP</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些基础的语法练习题（1）]]></title>
    <url>%2F2017%2F08%2F17%2F%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9A%84%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[折半查找int BinSearch(int array[], const int x, int size) { int begin = 0; int last = size - 1; if (begin &gt; last) { cout &lt;&lt; &quot;没找到！&quot;; return -1; } while (begin&lt;=last) { int mid = (last + begin) / 2; if (array[mid] == x) { cout &lt;&lt; &quot;找到啦，位置是：&quot;; return mid+1; } else if (array[mid] &lt; x) { begin = mid + 1; } else { last = mid - 1; } } cout &lt;&lt; &quot;没找到！&quot;; return -1; } int main() { int tar[] = { 2,4,6,8,10,12,14,16 }; int num = 0; while (1) { cout &lt;&lt; &quot;输入你要查找的数字：&quot;; cin &gt;&gt; num; int result = BinSearch(tar, num, 8); cout &lt;&lt; result &lt;&lt; endl; } system(&quot;pause&quot;); } 小球弹跳一个球从100米的高度自由落下，每次落地后反跳回原高度的一半。再落下，再反弹。求第10次落地时，共经过多少米，第10次反弹多高？ 分析：以反弹次数作为循环条件，反弹高度很容易求。但要注意第一次反弹后再落地时已经是小球第2次落地了。所以要注意小球反弹的次数和落地的次数并不一样，第10次落地在第10次弹跳之前，所以只能加9次。 12345678910111213 float sum = 100;float height = 100;int times;//反弹次数for (times = 1; times&lt;11; times++)&#123; height /= 2;//反弹高度 if (times &lt; 10) &#123; sum += 2 * height;//反弹后落地经过的长度 &#125;&#125;cout &lt;&lt; "height=" &lt;&lt; height &lt;&lt; endl;cout &lt;&lt; "sum=" &lt;&lt; sum&lt;&lt; endl; 字符汇聚int main() { char tar[] = &quot;************&quot;; char src[] = &quot;hello world!&quot;; int i = 0; int j = 0; printf(&quot;%s\n&quot;, tar); for (i = 0, j = strlen(tar) - 1; i &lt; j; i++, j--) { tar[i] = src[i]; tar[j] = src[j]; Sleep(1000); printf(&quot;%s\n&quot;, tar); } system(&quot;pause&quot;); } 登录系统int main() { char pass[] = &quot;hello&quot;; char enter[] = &quot;&quot;; for (int i = 1; i &lt; 4; i++) { cout &lt;&lt; &quot;请输入密码：&quot;; cin &gt;&gt; enter; if (strcmp(enter,pass)==0) { cout &lt;&lt; &quot;密码正确！&quot; &lt;&lt; endl; break; } else { if (i &lt; 3) { cout &lt;&lt; &quot;密码错误，你还有&quot; &lt;&lt; 3 - i &lt;&lt; &quot;次机会&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;密码错误，登录失败！&quot; &lt;&lt; endl; } } } system(&quot;pause&quot;); } 猜数字游戏void menu() { cout &lt;&lt; &quot;********************************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;猜数字游戏： 1-&gt;开始 0-&gt;退出&quot; &lt;&lt; endl; cout &lt;&lt; &quot;********************************&quot; &lt;&lt; endl; } int main() { int choice = 1; while (choice) { menu(); cout &lt;&lt; &quot;输入选项：&quot;; cin &gt;&gt; choice; switch (choice) { case 1: { cout &lt;&lt; &quot;~游戏开始~&quot; &lt;&lt; endl; int random = rand() % 100; int input = 0; while (1) { cout &lt;&lt; &quot;输入你猜的数：&quot;; cin &gt;&gt; input; if (input == random) { cout &lt;&lt; &quot;你猜对了!&quot; &lt;&lt; endl; break; } else if (input &lt; random) { cout &lt;&lt; &quot;你猜小了~&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;你猜大了~&quot; &lt;&lt; endl; } } } case 0: exit(1); default: cout &lt;&lt; &quot;没有此选项，请重新输入！&quot; &lt;&lt; endl; break; } } system(&quot;pause&quot;); return 0; } 猴子吃桃从前有只小猴子，摘了一大推桃子。第一天吃了一半，觉得不过瘾又吃了一个。第二天又吃了第一天剩下桃子的一半，还是多吃了一个。以后每天都吃了一半零一个桃子。到了第10天，只剩下了一个桃子，那么小猴子最开始摘了多少桃子？ 分析：因为每一天都吃了一半零一个桃子，多吃的那一个桃子是另一半的其中之一。所以第10天的桃子加1就是第9天桃子的一半，再乘以2就是第9天桃子的全部数量。以此类推就可以求出所有的桃子数量。 12345678910111213int main()&#123; int sum = 0; int num = 1; for (int i = 9; i&gt;0; i--) &#123; sum = (num + 1) * 2;//比前一天的一半少一个 num = sum; &#125; cout &lt;&lt; "sum=" &lt;&lt; sum &lt;&lt; endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>C/C++基础</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归求解1到100求和]]></title>
    <url>%2F2017%2F08%2F16%2F%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A31%E5%88%B0100%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[递归求解1到100的和是一个常见面试题。 思想： 思考一下，从1加到100可以分解成： 1+（2加到100的和） 1+2+（3加到100的和） 1+2+3+（4加到100的和） …… 怎么样，这样是不是有点递归的味道了？递归的出口就是1。 所以，可以编写如下代码： 代码： int count(int n) { if (n &gt; 1) { return n + count(n - 1); } else return 1; } 这样，不仅可以求1到100的和，还可以求任意区间数字的和。只要改变递归出口和上限即可。]]></content>
      <categories>
        <category>笔试面试题</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于闰年，你不知道的那些事]]></title>
    <url>%2F2017%2F08%2F16%2F%E5%85%B3%E4%BA%8E%E9%97%B0%E5%B9%B4%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[“四年一闰，百年不闰，四百年再闰”。你知道为什么吗？ 判断某一年是否是闰年几乎是所有编程语言的基础练习题之一，而我们必然也熟知其规则： 整除但4不能整除100 整除100又能整除400 这就是俗语中的“四年一闰，百年不闰，四百年再润”，我们当然可以根据这个规则编写程序判断闰年，但你知道为什么这样规定闰年的算法么？ 事实上，闰年是为了弥补因人为历法规定，造成的年度天数与地球实际公转周期的时间差而设立的。所以闰年有366天。 那么具体是怎么弥补的呢？ 我们知道，平年一年只有365天，而实际上地球绕太阳的公转周期为365天5小时48分46秒。即一回归年。所以公历的每一年都比回归年短0.2422天，四年累计起来，共短0.9688天。 大概就是一天，所以为了弥补这一天的时间差。给2月加上1天，就有了闰年。这样一来，每四年里就有一个闰年，3个平年。这就是四年一闰。 那么百年不闰，四百年再闰又是怎么回事呢？ 是这样的，刚才说四年累计起来的时间差只有0.9688天，这比我们给闰年增加的一天还少0.0312天，所以每四年就会多出0.0312天。这样400年后，就会比实际天数多出3.12天。所以我们必须在这400年中少设3个闰年。这样公历年的平均长度与回归年就近似了。 那这3个闰年怎么少呢？ 很简单，给百年除以400即可，比如2000-2400这400年： 2000/400=5 2100/400=5.25 2200/400=5.5 2300/400=5.75 2400/400=6 可以发现，正好有3个不能整除的整百年。所以规定年份是整百数的必须是400的倍数才是闰年。这就是百年不闰，四百年才闰的规定。 你明白了吗？ 当然，根据规则，我们就可以编写代码判断了： int main() { int year; cin &gt;&gt; year; if (year % 4 == 0) { if (year % 100 != 0)//1. 能整除4，不能整除100 { cout &lt;&lt; &quot;是闰年\n&quot; &lt;&lt; endl; } else if ((year % 100==0) &amp;&amp; (year % 400==0))//2. 能整除100， 又能整除400 { cout &lt;&lt; &quot;是闰年\n&quot; &lt;&lt; endl; } else//其它情况不是闰年 { cout &lt;&lt; &quot;不是闰年\n&quot; &lt;&lt; endl; } } else//不能整除4就不是闰年 { cout &lt;&lt; &quot;不是闰年\n&quot; &lt;&lt; endl; } system(&quot;pause&quot;); }]]></content>
      <categories>
        <category>C/C++基础</category>
      </categories>
      <tags>
        <tag>闰年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程互斥与同步（part2)—互斥锁（Mutex）的cp：条件变量(Condition Variable)]]></title>
    <url>%2F2017%2F08%2F14%2F%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%88part2%EF%BC%89%E2%80%94%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88Mutex%EF%BC%89%E7%9A%84cp%EF%BC%9A%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-Condition-Variable%2F</url>
    <content type="text"><![CDATA[条件变量（Condition Variable）和互斥锁（Mutex）的“cp”关系有句话叫“既生瑜，何生亮”，虽说互斥锁和条件变量都是为了维持线程间的互斥与同步。但他们可不是’瑜’和’亮’的关系。确切的说，他们俩是一对‘cp’。 首先，我们想象这样一个场景，有两个人，一个往盘子里放苹果；另一个从盘子中取苹果。 如果我们将盘子看作临界资源，把这两个人当作两个线程。加入互斥锁后，就形成了对盘子的互斥访问。如果一个人拿到锁进入临界区放苹果，此时另一个人也来申请锁想拿苹果。那么这个人代表的线程就会被阻塞。在第一个人拿锁和解锁之前的整个过程中，第二个人只能一直申请访问互斥锁，直到第一个人解开锁。 线程进入临界区之前要先访问互斥锁，像上述例子中由于两个人的优先级不同，优先级高的线程不断重复“拿锁-进入临界区-放锁”的过程，且不做实质性的工作（占着茅坑不拉屎）。导致优先级低的线程得不到时间片来访问互斥锁。这样就会形成线程的“饥饿”问题。为了解决这种问题，我们要保证对互斥锁的访问按某种顺序进行；使线程之间协同合作，这就是线程同步。 条件变量就是保证线程同步的一剂良药。 它提供了一种通知机制：在优先级高的线程放锁后立即通知别的线程取锁，若优先级高的线程想再次申请锁，只能在条件变量上挂起等待，这样就杜绝了优先级高的线程长时间霸占锁资源，实现线程间同步。其实质是用变量的形式来表示当前条件是否成熟，标志资源状态。从而方便线程之间协作运行。 有了条件变量，上边的例子就会变成这样： 总结一下：单纯的互斥锁用于短期锁定，主要是用来保证线程对临界区的互斥进入。而条件变量则用于线程的长期等待，直至所等待的资源成为可用的资源。 所以，一个Condition Variable总是和一个Mutex搭配使用（地表最强cp）。 Code（代码举例）知道了条件变量的概念，下面我们编写代码深入了解其作用。 首先了解一下条件变量主要的接口函数 一个线程可以调用 pthread_cond_wait函数在一个Condition Variable上阻塞等待,这个函数做以下三步操作: 释放Mutex 阻塞等待 当被唤醒时,重新获得Mutex并返回 具体唤醒多少线程与问题规模有关。一个线程可以调用 pthread_cond_signal唤醒在某个Condition Variable上等待的另一个线程,也可以调用 pthread_cond_broadcast唤醒在这个Condition Variable上等待的所有线程。 代码目的：实现基于单链表模式的生产者-消费者模型利用生产者-消费者模型和链表结构，生产者生产一个结点串在链表的表头上,消费者从表头取走结点。 科普时间：生产者与消费者模型？ 知道了这些基本概念，现在我们来编写代码： step1: 构建交易场所（临界资源）：链表 在编写链表基本操作Init,PushHead,PopHead,Destory函数后，运行程序： step2:创建生产消费者：2个线程 step3:保证互斥与同步：加入互斥锁保证线程之间的互斥访问 运行程序： 可以看到，虽然实现了互斥，但生产与消费并非间接进行，所以现象是长时间一直在生产，或一直在消费。这与实际情况不符。 step4:加入条件变量实现线程同步 我们对代码进行改造，如果生产者生产慢（sleep(1)），让消费者一直消费，且是无效消费（-1）， 就会出现下边的情况： 这是因为虽然消费者是无效消费，但它一直占用锁。导致生产者没有时间生产。这是由于对交易场所的状态一无所知导致的 所以由开始对条件变量作用的分析，结合刚才的结果，可以知道消费者也可能像优先级高的线程那样，有“拿锁-进入临界区（取数据）-放锁”的不断重复过程，但消费者将链表数据取完后就不应该再取了，所以要用条件变量来表示交易场所的状态（链表满或不满）。 所以在程序中加入条件变量，在生产函数里加入唤醒函数，消费函数里加入等待函数： 程序运行效果如下： 可以看到，尽管消费函数先运行只，但它在判断链表为空后只能在条件变量上挂起等待。只有在生产者生产后消费者才能消费，且生产一条，消费一条。 注：这里的pthread_cond_wait函数参数中的锁并非表示线程抱着锁挂起，而是释放锁之后再挂起。 step4: 另外，如果等待函数调用失败，还是会非法消费，所以加入检测：把 if -&gt; while 至此，条件变量结束。 The End其实仔细想想，上边的程序实际上是实现了一个栈，它符合后进先出的原则。 而且上述程序是生产1条，消费1条。且是在生产里边唤醒消费。其实我们还可以实现生产多条，通知1次的机制，只需要在生产函数里加入计数器即可。 另外，还可以实现生产者与消费者的互相通知唤醒机制，只需在程序中再加入一个条件变量，然后在消费函数里加入它的唤醒函数。 虽然 ‘cp’搭配，干活不累，但有时候单身狗的力量更强大（诶呀，好像剧透了&gt;~&lt;），好吧。本系列下一篇要介绍的就是“单身狗”—信号量的故事。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>条件变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO概念&5种IO模型介绍]]></title>
    <url>%2F2017%2F08%2F13%2FIO%E6%A6%82%E5%BF%B5-5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[本文介绍了IO概念和5种IO模型，希望能以最轻松的方式让大家理解这两个知识 ٩(๑&gt;◡&lt;๑)۶ Concept IO叫做输入输出，我们可以将IO理解为两步： 等待IO事件就绪 数据就绪后进行真正意义上的IO（真正的数据搬迁） 所以，IO的过程一是等，然后才是输入输出。 进而，我们可以得到评价IO是否高效的标准： 在IO过程中“等”的比重越小的性能越好，越大的性能越低。 IO中有两个重要的函数：read&amp;write 他们也有两个功能： 等 获取/写数据 等就是不能读和写，也就是写/读条件不就绪，即发送/接收缓冲区没有被写满，所以读写事件是否就绪通常要与文件描述符相关。 5种IO模型 1.一个故事 先给大家讲一个钓鱼的故事٩(๑&gt;◡&lt;๑)۶ ~风和日丽的一天，张铁锤拿着鱼竿和小板凳，提着桶，来到小河边钓鱼。~ 他先给鱼竿上放好鱼饵，然后就坐在自己的小板凳上，眼睛一直瞪着鱼竿的尽头。等到鱼上钩后，自己收竿把鱼放在桶里。 不一会，李狗蛋也来了。 他也和王铁锤一样，上好鱼饵之后就等鱼上钩。但他的做法是一边玩手机，一边瞄着鱼竿是否有动静，还不时的和王铁锤搭讪，但王铁锤并不理他，因为他在一动不动的盯着鱼竿，不能分心。 又过了一会，赵二毛也来凑热闹了， 但他多拿了一样东西———铃铛，他把铃铛系在鱼竿上，然后坐在小板凳上，拿出了一本《C和指针》看起了书，这样铃铛一响就直接收竿。嗯，文化人就是不一样。 今天钓鱼的人真不少，刘翠花也过来了， 但她放了个大招，直接拿了100多只鱼竿，全固定在岸边。这样几乎不用等，水池边全是她收竿的身影。不一会儿，就钓了好几桶鱼。 王老五看见这么多人钓鱼，顿时兴致也来了，但人家是老板，还有事要做。 于是吩咐司机让他去钓鱼，钓到了鱼就打电话通知他。只能说，有钱人就是不一样。 好了，我们的故事就讲到这里。 其实，钓鱼的过程和IO非常类似，要先等鱼上钩，然后才真正开始钓鱼。所以，上边的5个人实际上就对应了5种IO模型。 2. 5种IO模型 用这种讲故事的方式来介绍5种IO模型还是太口语化了，还是让我们严肃一点吧 (｡◕ˇ∀ˇ◕) 1. 阻塞IO 对于王铁锤，他一直看着鱼竿，自己等，自己钓，而且等的过程中不做其他的事。这就是阻塞IO： 阻塞式等待IO事件，在等的过程中不能做其他事。 2. 非阻塞IO 对于李狗蛋，他也是自己等，自己钓。但他并不是一直盯着鱼竿，而是时刻检测钓鱼事件是否就绪，没有就做其他的事（玩手机、搭讪）。这就是非阻塞IO： 非阻塞等待，不断检测IO事件是否就绪。没有就绪就可以做其他事。 3. 信号驱动IO 对于赵二毛，他将钓鱼事件是否就绪的信息转移到铃铛上，不用自己检测事件就绪，只需要将铃铛作为信号通知方式。这就是信号驱动IO： linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。 4. IO复用/多路转接IO对于刘翠花，她也是自己等，自己钓。但可以同时等待多个鱼上钩事件。这样她钓到鱼的概率就很大，等的时间短，效率明显比其他人高。这就是多路转接IO： linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数 5. 异步IO对于王老五（老板），他并没有经过等的过程，只需要发起事件（让司机钓鱼），然后享受结果。这就是异步IO： linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。 3. 区别与联系 前4种模型都有等和IO两个阶段，并将数据从内核拷贝到调用者的缓冲区，自己等，自己进行数据搬迁。所以统称为同步IO。 与第5种异步IO相区分。 注：这里同步/异步的概念与进程&amp;线程中的概念不同，不同的背景下应该有不同的理解。 The End本文通过一个小故事介绍了5种IO模型，希望能让大家更好的理解这几种IO模型的概念和区别。 告辞。。。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络通信模型总结：OSI&TCP/IP]]></title>
    <url>%2F2017%2F08%2F12%2F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93%EF%BC%9AOSI-TCP-IP%2F</url>
    <content type="text"><![CDATA[为什么需要网络通信模型？在第三代网络出现以前，网络是无法实现不同厂家设备互连的。早期，各厂家为了霸占市场，各厂家采用自己独特的技术并开发了自己的网络体系结构。 而不同的网络体系结构是无法互连的，所以不同厂家的设备无法达到互连，即使是同一家产品在不同时期也是无法达到互连的，这样就阻碍了大范围网络的发展。 为了实现网络大范围的发展和不同厂家设备的互连，网络模型应运而生。 说白了，网络模型的出现使得计算机之间可以更好的进行信息交换。 OSI七层参考模型为了实现网络大范围的发展和不同厂家设备的互连，1977年国际标准化组织ISO（International Organization for Standardization,ISO）提出一个标准框架——OSI（Open System Interconnection/ Reference Model,开放系统互连参考模型）共七层。 结构图示OSI模型把开放系统的通信功能划分为七个层次，从邻接物理媒体的层次开始，分别赋于1，2，……7层的顺序编号，相应地称之为： 物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。 每一层的功能是独立的。它利用其下一层提供的服务并为其上一层提供服务，而与其他层的具体实现无关。这里所谓的”服务”就是下一层向上一层提供的通信功能和层之间的会话规定，一般用通信原语实现。两个开放系统中的同等层之间的通信规则和约定称之为协议。通常把1~4层协议称为下层协议，5~7层协议称为上层协议： 像不像葫芦娃：葫芦娃，葫芦娃，一根藤上七个瓜。风吹雨打都不怕，啦，啦啦啦~ 各层详细说明如下表： 层数 作用 相关协议 相关设备 应用层 实现应用进程之间的信息交换，根据相应协议提供通信服务 HTTP\FTP\SMTPTELNET\SSH 应用程序，终端 表示层 把数据转换为能与接收者的系统格式兼容并适合传输的格式。 LPP/XDP 终端 会话层 负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。 SSL/TLS 终端 传输层 接收上层数据并交给网络层，保证数据传输可靠 UDP/TCP 终端 网络层 控制子网运行，将数据进行逻辑编址，路由选择，分组传输 IP 终端 数据链路层 物理寻址，将原始比特流变为逻辑传输线路。负责网络寻址、错误侦测（CRC）和改错 SLE/RRTP 网卡/网桥 物理层 为设备之间的数据通信提供传输媒体及互连设备，为比特流传输提供可靠的环境。提供有关同步和全双工比特流在物理媒体上的传输手段 RS232C、RS449/422/423、V.24/X.21、X.21bis 针脚/电压/线缆规范/集线器/中继器/网卡/主机适配器/空明线/平衡电缆/光纤/无线信道 网上有张大图，比较高能： TCP/IP四层参考模型 当无线网络wifi和卫星出现以后，现有的协议在和它们相连的时候出现了问题，所以需要一种新的参考体系结构。这个体系结构在它的两个主要协议出现以后，被称为TCP/IP参考模型 结构图示TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下层所提供的网络来完成自己的需求。这4层分别为： 各层详细说明 层数 作用 相关协议 应用层 应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务 HTTP\FTP、SMTP 传输层 传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性 TCP/UDP 网络互联层 网际互连层对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。 IP/ICMP/IGMP/ARP 网络接入层 网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。 —— 区别 相同点 SI参考模型和TCP/IP参考模型都采用了层次结构的概念 都能够提供面向连接和无连接两种通信服务机制 不同点 OSI是七层模型，TCP/IP是四层结构 对可靠性要求不同（TCP/IP更高） OSI模型是在协议开发前设计的, 具有通用性.TCP/IP是先有协议集然后建立模型, 不适用于非TCP/IP网络. 实际市场应用不同（OSI模型只是理论上的模型，并没有成熟的产品，而TCP/IP已经成为“实际上的国际标准”）]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>IP</tag>
        <tag>OSI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试工具调研]]></title>
    <url>%2F2017%2F08%2F12%2F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[测试工具测试管理工具TestLinkgitTestDirector（TD，基于web）缺陷跟踪工具BugzillajiraMantisBugFree软件自动化测试工具web测试web自动化测试工具：seleniumweb性能/压力测试工具：LoadRunner jmeterweb安全性测试工具：AppScanapp自动化工具appiumMonkeyMonkey Runneruiautomator手机端测试Robotium（Android,开源）Instruments （IOS, 开源）白盒测试（单元测试）工具gtestjtest黑盒测试：Bugtags持续集成工具：jenkins其他QTP(quicktest Professional)代码扫描工具cppcheckgcovercoverityfindbugs测试辅助工具抓包工具FlidderWireShark]]></content>
      <categories>
        <category>技术调研</category>
      </categories>
      <tags>
        <tag>测试工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[王者荣耀，荣耀了谁?]]></title>
    <url>%2F2017%2F08%2F11%2F%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%EF%BC%8C%E8%8D%A3%E8%80%80%E4%BA%86%E8%B0%81%2F</url>
    <content type="text"><![CDATA[你玩过王者荣耀吗？ 在当下，以《王者荣耀》、《阴阳师》为首的一批手游正逐渐霸占人们的手机屏幕，以此而衍生的电竞、直播以及代练行业风光无限，潜力巨大。 最近，为保障未成年人健康成长，腾讯经过将近一个月的调试和内测后，于7月4日以《王者荣耀》为试点，率先推出健康游戏防沉迷系统的“三板斧”，对未成年人的游戏时间作出限制：12岁以下每天限玩一小时。（小学生听了绝不会流泪，并笑着拿出奶奶的身份证。） 当前国内还没有移动游戏防沉迷的明确规定，《王者荣耀》在顶着“亡者毒药”的社会舆论中做出了实际行动，这是一种自保行为，也可以说是社会责任感的体现。 但事实上，《王者荣耀》的最大玩家群体当属大学生和中年人群体，第三方数据分析机构talkingData统计的数据显示，王者荣耀的用户群中，大学生占21.8%，中小学生占2.7%；上班族占68.7%。 在我的一个宿舍微信群里，大家平时只会在中午和晚上掷骰子，决定谁去拿外卖，平时没人聊天。然而时至今日，群里的聊天已经变成了对暗号： “来？” “嗯。” “洗澡，很快。” “卡住了，等会。” 《王者荣耀》自2015年公测以来，已经度过2年多的光阴了，游戏人群也如同滚雪球般越来越庞大。 一个值得思考的现象是，女性玩家的比例越来越高，占比超过了男性，达到54%。为了增强用户的粘性，游戏里甚至催生出社交的属性。 我有一个朋友连续玩了三个月的《王者荣耀》，最后他终于卸载了，疲惫地跟我吐槽：“太累了，打上一盘都得几十分钟。更惨的是，有时候你开局就知道自己输定了，还得耐着性子打下去，否则会被人举报，真TM绝望，浪费时间。” 显然，小学生群体也有他们的无奈，有一位小学生说出了自己的无奈： 我不是一个热衷于《王者荣耀》的学生。我想说的是，在学校这个大熔炉里，所有的人都在玩这个游戏，如果你不玩，你就会显得与其他人格格不入，别人聊的内容你听不懂，就会有一种被孤立的感觉。” 道理我都懂，真难为这位不做作的小学生了。 现在，玩《王者荣耀》的人群可以归类为四类人群： 第一类是资深钻研党，他们需要了解王者荣耀的游戏机制及运行架构，以求完善自己的产品。 第二类是依托于游戏而衍生的代练工作室，他们成功通过游戏的漏洞来赚钱。 第三类是把游戏当成消磨工具的富裕人群，也就是俗称的人民币玩家。 第四类是覆盖人群最广的普罗大众，他们纯粹把游戏拿来消磨时间。 若总结来看，游戏人群真正只需划分为两类，一类是玩游戏的人，以此赚钱发家；另一类是被游戏玩的人，深陷进去而无可自拔。 根据极光数据6月中旬最新发布的《王者荣耀》研究报告显示，目前《王者荣耀》的用户群体收入水平3001-8000元的占据多数，占比为47.8%；3000元以下的占27%；8000元以上占据25.2%。 也就是说，收入在8000元以下的《王者荣耀》用户数占比达74.8%。 根据二八定律来看，80%的玩家收入都是在8000元以下，他们在游戏里陪着20%的有钱玩家。 我在一个论坛看到有个网友在感慨：“我从01年开始玩传奇，然后06年进了魔兽的坑，16年转战部落冲突，接下来阴阳师和王者荣耀都都没放过。而现在我最好的朋友年薪已过百万了，而我还是个月薪3000的修车工……唉，转眼间就过去十六年了，时间过得飞快，我却一直原地踏步。” 网上有不少报道将《王者荣耀》批判为精神鸦片，这个观点我觉得过于偏激了，把自身自制力差的原因归咎于外物，怨天怨地怨社会，这样挺蠢的。 如今小学生群体被腾讯严格控制游戏的时间，成年人当然没这个必要，要对自己的行为负责。 于是，一种很残酷的事实在现实中发生，大部分人的工作时间都是固定的，能自由安排的空闲时间本就稀少，而这宝贵的时间还被游戏无情地夺走了。这个措辞不太严谨，应该说是双手拱让出来。 你可以想象成，每天上班做着简单枯燥的活，对自身的人生规划难以提高，好不容易有了自己做主的时间，却被游戏抢走了。等你疲惫地退出游戏界面时，却发现自己一无所获，精神空虚，说好的自我提升计划又荒废了。 有些人可能会说我过于上纲上线，他每天的自控力很强，玩上半小时就会退出，不影响生活。那我恭喜你，你是一个有明确目标，且自制力很强的人，所以无需对号入座。 但很多人或许都是这种状态： 上班满脑子想着游戏，和同事交流攻略和技巧，趁领导不在，赶紧来一把。下班了在地铁上继续玩，吃完饭后躺在床上开黑。有时候得加班了，没关系，通宵补回来就好，不玩到两点绝不罢休。 我相信，每个人都不满足于现状，总想着往上爬，抗衡着现实社会的阶级枷锁，却找不到那根往上的绳子，于是只能原地悬空，陷入不上不落的状态。 这时何不锻炼自身的体格，最终不去依仗那根绳子，用自己的双手往上爬呢？ 你若想不明白这种道理，就永远在贫穷怪圈内兜转，跳脱不出。 贫穷=生活质量低=眼界低=目标模糊=动力不足=浪费时间=工资低=贫穷。 很多人或许会继续辩解：玩游戏、泡吧等是一种休息的方式，白天工作如此地劳累，人生如此艰难，何必再为难自己？ 这句话看似没有毛病，但我不敢苟同，我想起《纸牌屋》的主角佛朗西斯，他在外面得跟各路政坛狐狸斡旋，充满着尔虞我诈和勾心斗角，在家里还要面对一个强势的老婆，人生同样显得异常艰难。 但他和在座的各位有个共同爱好：就是玩电子游戏，这就是他休息的方式。 我想问一下，你和佛朗西斯的工作性质相仿吗？ 你是叱咤政坛的领袖呢，还是某企业的高管，每天都忙的心力交瘁？ 事实上，你也辛苦忙碌了一天，证明你不是一个啃老族。但或许你只是日复一日地做着简单的工作，重复着低效率的勤奋。尤其在体面及高大上的企业，部门间分工极为仔细，每个人都只是一颗维持企业运转的螺丝，你转的再快，也只是原地转动的螺丝而已。 但你转的慢，就会面临被淘汰的局面。 在20世纪末曾大面积地出现下岗潮，国企的铁饭碗被打破，大批普通人的命运因此而改变。 如今随着钢铁和煤炭两个行业去产能化，一个下至底层，上至管理层都不愿面对的问题又出现了。历史是否会重演，我们不得而知。 Facebook的创始人小扎坦言：未来会有数以百万计的工作被人工智能取代。微软的比尔盖茨也说过：我建议大学毕业生从事和AI相关的职业。 普华永道夜在今年初大胆预测，在2030年以前，美国有38%的工作将完全被自动化的机器、电脑程序所取代。 这并非危言耸听，如今，银行信审员已经成为第一批被AI干掉的金融民工。在以前，人工审一天不过50单，现在机器审核量超过一万单，在线上的高频交易中，人已经完败于机器。 再列举一组数据： 仅2015年，广东就有6万台左右机器人在车间上岗，替代了至少6万工人；在2016年，富士康位于江苏昆山的工厂用机器人替代了6万个工人，员工人数从11万减少到5万。而在昆山，还有大约600家企业也想要效仿富士康，用机器人替代人工生产: 可以看出，未来被替代的大多是枯燥和重复的工作，它们技术含量低且难以创造新的价值。以此诞生的新行业和工作岗位将是以操作、维护、安装调试工业机器人为主，技能人才缺口同样巨大。 新岗位永远有缺口，这就需要你争分夺秒地去适应，去学习，去抢工作。毕竟这个世界永远没有安逸而稳定的工作。 如今刚毕业的大学生，他们很容易陷入低水平的勤奋：每天累死累活，看着拿到手的工资转眼间被高额的房租所掏空，然后没有总结自身的原因，一味怨社会不公，哪家公司刻薄，哪个体制不行，在网络上愤怒地抨击一番后，拿起手机继续开黑。 抱歉，这只能说明你还未适应这个社会的节奏，你还停留在无忧无虑的学生生涯，安详度日。 没有一个合理合规的作息时间，其实是封锁了提升自己的通道。 我们很多人在周末双休，都想着放松自己，调养身心。尽管你们放肆地深夜煲剧、泡吧蹦迪、烟酒撸串，但你们还是一个守法的好公民，只是到了周一上班，一个个精神萎靡神似吸毒，感觉身体被掏空，还得承受着同事的异样目光。 一位网友反怼我：智先生，你说的是什么狗屁？难道因为我穷，我没能力，就没有人权玩游戏、听音乐、上网，连基本休息的权利都没了？ 在这里，我希望他能区分开休息和娱乐的定义： 休息是一种恢复，以储备充电为目的。玩乐是一种娱乐，以满足身心为目的。 我主张将两者分开：玩就要开心地玩，休息就得好好休息。真正想休息者，就不要去玩乐，因为不仅没给你充电，反而消耗了心神，会更加地疲劳。（我的话太啰嗦了，大家都是年轻有为的社会主义接班人，双商都在线。） 趁着年轻，多挤出时间去提升自己，放手去追求，失败了又如何，反正不会死，万一成功了呢？ 最后我想强调，本文并非批判《王者荣耀》，即便它没有木秀于林，也还会有诸如亡者荣耀、你最荣耀等手游相继出现，继续霸占大家的手机屏幕。 一个人内心不做出真正的改变，只会被永远牵着鼻子走，这时候就不要怪游戏太迷人了。 真正拼搏中的精英，都在感谢蹉跎中的你们。 本文转载自简书，原文链接：我们该感谢王者荣耀耗尽了80%的人上升的空间]]></content>
      <categories>
        <category>生活随想</category>
      </categories>
      <tags>
        <tag>王者荣耀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sizeof 和 strlen的区别]]></title>
    <url>%2F2017%2F08%2F11%2Fsizeof-%E5%92%8C-strlen%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[先来看一段代码： 123 char* p1 = "helloworld";char p2[] = "helloworld";printf("%d, %d, %d, %d\n", sizeof(p1), strlen(p1), sizeof(p2), strlen(p2)); 运行结果： 4 10 11 10 没错，这就是sizeof和strlen的区别，在字符串长度的计算中。strlen不会加上’\0’.]]></content>
      <categories>
        <category>C/C++基础</category>
      </categories>
      <tags>
        <tag>sizeof</tag>
        <tag>strlen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程互斥与同步（part1）—互斥锁（mutex）的原理及其实现机制]]></title>
    <url>%2F2017%2F08%2F10%2F%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%88part1%EF%BC%89%E2%80%94%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88mutex%EF%BC%89%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一段代码引发的问题首先，我们来编写一段代码，它的目的是定义一个全局变量，创建两个线程对其进行5000++的操作。 运行结果如下： 当然，目前来看，这段程序并没有任何的问题。 然而，对于此程序，结合线程的特点，我们需要明确两点： 局部变量 i 不是共享的，因为它在栈中 gCount是共享的，因为它是全局变量，属于代码段。 我们知道，只要是共享的资源，那么它就可以看作临界资源，而临界资源的访问需要同步与互斥机制才能维持正常访问。否则可能会出现数据不一致的问题。 下面，我们来讨论一种情况： 假设上边的程序中，线程1先运行。 它在物理内存中读到gcount=0后被切换出去（保存上下文信息）。当线程1重新换回来时，还认为gcount是0，因为它不会再从物理内存中读取。 而此时，线程2开始运行，它在物理内存中也读到gcount=0然后将gcount加到5000，接着又被切换出去。然后线程1再接着运行，将gcount加到1。又被切换了出去。 最后，线程2再运行时也不会再从物理内存中读取gcount的值，它从上下文信息中得知gcount的值为1。这样问题就出现了，本来线程2已经将gcount加到了5000，现在它又从5000变成了1。如此下去，gcount的值就是不确定的。 为什么会出现这样的问题呢？ 这是因为对gcount计数器的操作是非原子性的，所以导致了数据不一致的问题。 多个线程同时访问共享数据时可能会冲突。 比如上边的两个线程都要把全局变量增加1,这个操作在某平台需要三条指令完成: 从内存读变量值到寄存器 寄存器的值加1 将寄存器的值写回内存 假设两个线程在多处理器平台上同时执行这三条指令,则可能导致最后变量只加了一次而非两次。 那为什么上边的程序结果无误呢？ 其实如果是以前的电脑，可能会出错。然而现在的计算机计算速度太快了，线程之间的干扰不够严重。 为了证明确实会出现这种数据不一致的问题，我们对程序进行改造，加大线程之间的干扰力度。 如何加大线程之间的干扰力度呢？有一种比较重要且容易实现的手段：触发线程间切换 知识科普 内核态：操作系统的模式，如果用户或某程序进入了内核态，那么它的权限就会不受约束，可以做任何事。操作系统向外提供系统调用接口方便进行用户态到内核态的转变。 用户态：一般用户的模式，用户或某程序在此状态下只能调用用户代码，权限受约束。当用户想调用系统接口，执行内核代码，就要从用户态变成内核态。 触发线程间切换：在线程执行函数代码中多次进行系统调用，使其不断地从用户态到内核态。这样多个线程之间就会相互干扰。 科普结束。。。 让我们回到问题中，其实上边的程序代码中有一个系统调用：printf 但它调用的次数不够，而且代码也不够复杂，所以对代码进行改造，在“读取全局变量gCount的值”和“把变量的新值保存回去”这两步操作之间插入一个printf调用。它会执行write系统调用进内核，为内核调度别的线程执行提供了一个很好的时机。一个循环中重复上述操作几千次,就会观察到访问冲突的现象。 加入局部变量tmp，使其代替gCount进行++操作，将数据++的过程分成两部分，增加系统调用的次数。改造后的代码如下： 接下来再运行程序，就会出现上述数据不一致导致的错误结果。而且多运行几次，它的结果也是不确定的。 好了，折腾了半天，终于找到了问题。那么如何解决这个问题呢？ 解铃还须系铃人，要解决问题，归根结底就是要解决线程之间互相干扰的问题，从而保证临界资源的原子性。 互斥锁（mutex）就是这里的解铃人。 互斥锁（mutex)对于多线程的程序,访问冲突的问题是很普遍的,解决的办法是引入互斥锁(Mutex,Mutual Exclusive Lock)。 获得锁的线程可以完成“读-修改-写”的操作,然后释放锁给其它线程,没有获得锁的线程只能等待而不能访问共享数据。这样“读-修改-写”三步操作组成一个原子操作,要么都执行,要么都不执行,不会执行到中间被打断,也不会在其它处理器上并行做这个操作。 Mutex⽤用pthread_mutex_t类型的变量表示。 相关函数如下表： 有了互斥锁的概念，下面我们来利用它解决上边的问题，在程序中用宏PTHREAD_MUTEX_INITIALIZER初始化lock互斥锁，并加入加锁解锁函数。修改后代码如下： 我们再来运行代码： 结果正确，说明互斥锁的却解决了问题。 其实，如果我们将代码中循环次数变大，即使没有系统调用触发进程间切换，也会出错。 上边的程序中，将循环次数加到5亿，代码运行结果也是错的。 接着我们加入互斥锁 程序运行结果再次恢复正常（此过程时间较长，因为加锁占用系统资源，程序运行时性能变低（线程在加琐时是串行运行））。 到这里，我们已经解决了问题。 lock和unlock实现原理刚才我们用互斥锁解决了进程切换引发程序运行错误的问题，那么Mutex的两个基本操作lock和unlock是如何实现的呢? 假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁。而Mutex的值为0表示互斥锁已经被某个线程获得,其它线程再调用lock只能挂起等待。 基于此，我们先来看第一种lock和unlock实现的伪代码： 因为unlock过程一定是原子的，所以我们把视线主要集中在lock过程。 我们知道，unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程。然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。 然而仔细观察我们就可以发现问题：上述为代码中lock函数里对Mutex变量的读取、判断和修改并非原子操作。如果两个线程同时调用lock,这时Mutex是1，而两个线程都判断mutex&gt;0成立。然后其中一个线程置 mutex=0，而另一个线程并不知道这一情况,也置mutex=0,于是两个线程都以为⾃⼰获得了锁。 这种情况类似于刚才对全局变量gCount的操作。 因为线程在任何时候都可能被触发导致切换，而在每个线程运行时，mutex都会首先被读到CPU里。这将导致mutex的副本过多，数据依然无法保持一致性。所以这种伪代码的实现是错误的。 下面我们来看另一种实现方法： 首先利用汇编指令xchdb将已置0的寄存器a1与互斥量mutex值进行交换。只对寄存器操作，所以就不会产生物理内存中的mutex副本。这样即使线程在执行xchgb指令和条件判断时被切换出去，也是没有任何意义的，对程序结果并没有影响。unlock中的释放锁操作同样只用一条指令实现,以保证它的原子性。 所以这才是lock和unlock的实现原理。 注：为了实现互斥锁操作,⼤大多数体系结构都提供了swap或exchange指令,该指令的作用是把寄存器和内存单元的数据相交换,由于只有一条指令,保证了原子性,即使是多处理器平台,访问内存的总线周期也有先后,一个处理器上的交换指令执行时另一个处理器的交换指令只能等待总线周期。 知识点：上述为代码中挂起等待和唤醒等待线程操作的实现机制： 每个Mutex都有一个等待队列，一个线程要在Mutex上挂起等待，首先要把自己（pcb）加入等待队列中,然后置线程状态为睡眠状态。然后调用调度器函数切换到别的线程。一个线程要唤醒等待队列中的其它线程，只需从等待队列中取出一 项,把它的状态从睡眠改为就绪，加入就绪队列。那么下次调度器函数执行时就有可能切换到被唤醒的进程。 死锁(Deadlock)正所谓“一波未平，一波又起”，世界上并没有完美的东西。 所以尽管我们能用互斥锁解决线程互斥，但同时互斥锁的引入也会导致另外的问题。这就是死锁。 如果你要问我一个互斥锁会不会产生死锁，我的答案是当然会。试想一下，一个人走在路上自己都能把自己绊倒。那么互斥锁么，呵呵…… 死锁产生原因 情形一：竞争资源 如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁；然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁,。因此就永远处于挂起等待状态了。叫做死锁(Deadlock)。 情形二：线程推进顺序不当 假设线程A获得了锁1，线程B获得了锁2。这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1。于是线程A和B都永远处于挂起状态了。 死锁产生条件 1.互斥2.请求与保持3.不可抢占锁资源4.循环等待 不难想象，如果涉及到更多的线程和更多的锁。死锁的问题将会变得更加复杂和难以判断。 所以，为了避免死锁的产生，使用互斥锁时应尽量避免同时获得多个锁，且应遵循以下原则： 线程在需要多个锁时都按相同的先后顺序(常见的是按Mutex变量的地址顺序)获得锁。⽐如一个程序中用到锁1、锁2、锁3，它们所对应的Mutex变量的地址是锁1&lt;锁2&lt;锁3, 那么所有线程在需要同时获得2个或3个锁时都应该按锁1、锁2、锁3的顺序获得。 尽量使用pthread_mutex_trylock调用代替 pthread_mutex_lock 调用 The End尽管我们可以遵循上面的原则，但还是不能完全避免死锁的产生。 为了解决死锁的问题，需要引入更多的线程互斥与同步机制，如条件变量等。敬请期待Part2.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>互斥锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱你就像爱生命]]></title>
    <url>%2F2017%2F08%2F08%2F%E7%88%B1%E4%BD%A0%E5%B0%B1%E5%83%8F%E7%88%B1%E7%94%9F%E5%91%BD%2F</url>
    <content type="text"><![CDATA[你要是愿意，我就永远爱你，你要是不愿意，我就永远相思。 王小波一直是我喜欢的作家之一，更令人惊讶的是，他竟然还是个程序员。 虽然他的作品部部经典，引人深思。但这一篇写给他妻子李银河的情书，却能真正打进人的内心。每看一遍都回味无穷，这是一篇极美的文章，堪称史上写的最好的情书，原来世间仍有这么好的爱。 你要是喜欢了别人我会哭，但是还是喜欢你。 你是非常可爱的人，真应该遇到最好的人，我也真希望我就是。 我是爱你的，看见就爱上了，我爱你爱到不自私的地步，就像一个人手里一只鸽子飞走了，他从心里祝福那只鸽子的飞翔。你也飞吧，我会难过，也会高兴，到底会怎么样我也不知道。 不管我本人多么平庸，我总觉得我对你的爱很美。 我现在已经养成了一种习惯，就是每天要对你说几句不想对别人说的话。 有时候你难过了，这个时候我更爱你，只要你不拒绝我我就拥抱你，我会告诉你这是因为什么，就是我不知道是为了什么。 我爱你，这是我的命运。 我决不为了仪式爱你，我是正经爱你呢。我一正经起来，就觉得自己不坏，生活也真不坏。真的，也许不坏？我觉得信心就在这里。 但愿我和你，是一支唱不完的歌。 我真的是个好人，我对好多人怀有最深的感情，尤其是对你。我很想为别人做好事，尤其是对你，我真想把我做出的一切好事全献给你了。 我们是两个在宇宙里游荡的灵魂，我们不愿孤独，走到一起来，别人与我们无关。我把我的整个灵魂给你，连同它的怪癖耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。 只希望你和我好，互不猜忌，也互不称誉，安如平日，你和我说话像对自己说话一样，我和你说话也像对自己说话一样。 说吧，和我好吗？]]></content>
      <categories>
        <category>美文</category>
      </categories>
      <tags>
        <tag>王小波</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAT&代理服务器技术调研]]></title>
    <url>%2F2017%2F08%2F07%2FNAT-%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[相信用过facebook等其他国外社交网站的小伙伴，都离不开一个东西——**软件。 为什么不能直接通过网络连接访问这些网站，而要借助于这些软件呢？这个嘛，你懂得。。。 本文将介绍其背后的机制：NAT&amp;代理服务器技术 Key Point： 引言：为什么需要NAT&amp;代理服务器技术 2者概念及区别 引言 如果一个组织内部组建了局域网，那么IP地址将只用于局域网内的通信，而不直接连到Internet上。 理论上，使用任意的IP地址都可以连接网络，但是RFC1918规定了用于组建局域网的私有IP地址，这些地址不会出现在Internet上。 那这些私有IP地址就不能连接Internet了么？ So…… 使用私有IP地址的局域网主机虽然没有Internet的IP地址，但也可以通过代理服务器或NAT(网络地址转换)等技术连到Internet上。 Concept NAT技术 概念关于NAT技术，百度百科的介绍是这样的： 博主最近又开始在百度盗图了，我的错，我有罪╮(╯﹏╰）╭ 根据概念我们可以总结： 所谓NAT技术，就是在一个主机只能有一个IP地址的情况下，利用NAT路由器，将自身IP地址转换为一个有效的外部全球地址，从而连接全球Internet的技术。 技术背景再来818它的技术背景： 所以，路由器真是个好东西୧(๑•̀⌄•́๑)૭碉堡 到这里，相信你已经对NAT技术有一个大致的了解了，但是我们还要知道它的原理和工作流程。 原理和工作流程 从上边的概念我们可以知道，借助于NAT，私有（保留）地址的”内部”网络通过路由器发送数据包时，私有地址被转换成合法的IP地址，一个局域网只需使用少量IP地址（甚至是1个）即可实现私有地址网络内所有计算机与Internet的通信需求。 再来看一下它的工作原理： Step1： client（终端） 的 gateway （网关）设定为 NAT 主机，当要连上 Internet 的时候，该封包就会被送到 NAT 主机，这个时候的封包 Header 之 source IP（源IP） 为 192.168.1.100 Step2： NAT 主机将 client 的对外联机封包的 source IP ( 192.168.1.100 ) 伪装成 ppp0 ( 假设为拨接情况 )这个接口所具有的公共 IP ，因为是公共 IP 了，所以这个封包就可以连上 Internet 了，同时 NAT 主机会记忆这个联机的封包是由哪一个 ( 192.168.1.100 ) client 端传送来的 Step3： Internet 传送回来的封包由 NAT主机来接收，NAT 主机查询原本记录的路由信息，并将目标 IP 由 ppp0 上面的公共 IP 改回原来的 192.168.1.100 Step4： 由 NAT 主机将该封包传送给原先发送封包的 Client 这就是NAT技术的原理。 代理服务器技术 概念 所谓“代理”，就是代而劳之的意思。代理服务器就是代理网络用户去取得网络信息，形象的说：它是网络信息的中转站，使得一个网络终端和另一个网络终端不直接进行相连，而由代理服务器代理网络用户去取得信息。主要工作在OSI的会话层中。 功能代理服务器（Proxy Server）是Internet链路级网关所提供的一种重要的安全功能，主要的功能有： 工作流程一个完整的代理请求过程为： Step1： 客户端与代理服务器创建连接，接着根据代理服务器所使用的代理协议，请求对目标服务器创建连接或者获得目标服务器的指定资源（如文件）。 Step2： 如果客户端索要获取的资源在代理服务器的缓存之中，则代理服务器并不会向目标服务器发送请求，而是直接返回缓存的资源。 注意以下几点： 一些代理协议允许代理服务器改变客户端的原始请求、目标服务器的原始响应，以满足代理协议的需要。 代理服务器的选项和设置在计算机程序中，通常只包括一个“防火墙”，允许用户输入代理地址，他会这该他们的网络活动，可以允许绕过互联网过滤实现网络访问。 区别 虽然NAT技术和代理服务器技术都可以解决“翻墙”问题，但他们的区别可不小。 突出在以下几点： 运算成本和网络性能方面 NAT:使用路由器，成本较低 代理服务器：成本较高 网络安全性方面 NAT: 工作原理决定了IP地址不能隐藏，用户主机容易受到攻击 代理服务器：用户可以隐藏IP地址，以防受到攻击，安全性较高 访问速度 NAT: 工作流程使访问速度受限 代理服务器：设置了一个较大的硬盘缓冲区，当有外界的信息通过的时候，同时也将其保存在缓冲区中，当其他用户在访问相同的信息时，则直接有缓冲区取出信息，传给用户，以提高访问速度 IP开销 NAT: 要为局域网（LAN）内的每一个用户都申请一个IP地址 代理服务器：允许使用大量的伪IP地址，节约上网资源，即代理服务器可以减少对IP地址的需求 The End 知道了这两个技术，以后看到舍友用facebook的时候还能顺便装个逼。妙哉妙哉…… 本文引用： NAT技术百度百科 代理服务器和NAT技术 本文首次发表在博主的CSDN博客，链接：http://blog.csdn.net/summy_j/article/details/74145017]]></content>
      <categories>
        <category>技术调研</category>
      </categories>
      <tags>
        <tag>NAT</tag>
        <tag>代理服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GithubPages&CodingPages搭建自己的个人博客]]></title>
    <url>%2F2017%2F08%2F06%2FHexo-GithubPages-CodingPages%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[首先声明：这并不是一篇教程。 这不是一篇教程，原因有4个： 博主太懒了，而且文笔也很差。 写教程需要把之前的过程再过一遍，博主没有时间也没有耐心。 中间要在github上创建个人的github.io库，而这个库每个账号只能有一个。为了写教程再去申请账号太麻烦了。 最后一点，也是最重要的一点：网上的教程已经很多了，而且有的文章写的确实不错。我的博客就是参考网上的教程搭建的，既然我没有人家写得好，就没有必要写。 我想有的人会问了：那这篇文章是干嘛的呢？ 问得好。 我想在你看到我的这篇文章之前，各位小可爱一定还见过或者收藏了其他关于搭建博客的的文章，以便对比，查漏补缺式的开始搭建。博主搭建博客的时候也是这么做的。 所以，本文将把我从开始想搭建博客，到最后搭建成功的整个过程中，用到的所有文章链接做一个汇总。这样可以减少你在网上搜索教程，过滤有用文章的时间。而且还方便博主以后查看，让一切变得简单。 怎样汇总呢？ 我是这样做的，把文章分为5个部分。根据我的经验，这5个部分是你整个博客搭建过程中必须要思考和实践的： 前言：搭建博客难吗 &amp; 为什么要搭建博客 背景知识：Hexo &amp; Github &amp; GithubPages &amp; CodingPages 搭建过程：重头戏 个性化：本文链接最多的一个部分，原因你懂的 我的建议和踩过的坑 最后一个部分穿插在前4个部分中，能让你更快的进行博客搭建，所以不作为单独的目录出现。 如果你不想了解前两个部分，可以直接跳到第3部分。 好了，废话就不多说了，开车! 前言搭建博客难吗？我可以很负责人的告诉你：不仅不难，而且还很简单。 那么，只有程序员才能搭建博客吗？ 或许你不相信，但我确实见过有许多非互联网行业的人也搭建了自己的博客。所以在搭建博客这件事上，确实没有专业之分。 说白了，搭建博客就是用一堆别人的东西，来做一个你自己的东西：Hexo、主题、GithubPages、CodingPages，这些没一样是你的。而且这些都是免费的，除了买域名要花一只棒棒糖的钱（我搭建博客一共就花了3块钱） 所以，人家设计的东西，你只要拿来用就可以了。 需要自己知道一些背景知识吗？上边说了，搭建博客是没有专业之分的。你可以不知道什么是Github,hexo,GithubPages/CodingPages。甚至在技术方面什么也不懂。 可能你不相信，但结合我的搭建过程，我可以先给你说说他们都是怎么用的： Github：只是建立了一个github.io的库，没有账号的话可以注册一个。所以你有没有账号，会不会操作Github都没有关系。 Hexo：只是下载了它的安装包和主题，你只需要知道一些部署博客的命令（不超过5条）。这些命令你也可以不会，因为文档里都有。 GithubPages：是Github推出的功能，只要你建立了github.io库，就默认在使用。它相当于一个服务器，可以保存你的所有博客文件，是你电脑上博客站点的一份备份。也不用你了解。 CodingPages：跟GithubPages作用相同，也是为了备份。所以你可以不用这个。但这个是国内的。为了双重保障和你的博客运行速度。建立还是设置下它。 它们的概念下边会详细介绍。 当然，搭建博客时你可以什么都不懂。但为了以后能更好的操作你的博客，建议在搭建成功之后，好好学习一下Github的使用。网上的教程也有很多，这里就不再赘述。 虽然你可以什么都不懂，但以下3样东西你必须要有： 耐心：搭建博客是一件非常折腾的事情，所以耐心很重要 细心：一定要细心，确保每一步都是正确的。 一定的学习能力和钻研精神，遇到困难一定要面对它，主动解决。 为什么搭建博客？这个问题相信你已经有了自己的答案，但我还是建议你看看这2篇文章： 我为什么坚持写博客？ 为什么你要写博客？ 搭建博客需要多长时间？这个因人而异，在我看来，有这么几种： 半天：只是搭建，不涉及到换域名和个性化，并且了解背景知识。那么只要半天便可以搭建完成 一天：需要了解背景知识，并且换了域名和主题，但没有太多的个性化 两天：设置了评论，字数统计等各种个性化设置（比如我） 三天甚至更多：各种找个性化插件和设置，一直在折腾的人 当然，前两种都是你没有遇到太大的坑或者困难所给出的估计时间。如果你在搭建的时候碰到了很多的问题，那么这个时间就得延长了。因为这种问题一般不好查。 背景知识搭建博客之前，你应该知道自己在做的是什么。先把事情做对，再把事情做好。所以你需要了解一些背景知识。 建立博客的渠道 通常来说，建立博客的通常渠道包括以下3种： 在博客平台上注册，比如 博客园、CSDN、新浪博客 等。 利用博客框架搭建，如 WordPress、Jekyll、hexo 等。 自己用代码写一个。 其中，第一种最简单，也最受限，说不定还会被删帖删号（我就遇到过这种情况）。第二种稍复杂，另外需要自己找部署的服务器，但可定制化较高，是很多人的选择。最后一种，是在重复造轮子，不过从另一个方面来看，倒是锻炼编程能力的好方式。 而我们要做的，就是第二种：既不受限，难度也不大。 为什么选择GithubPages和Hexo用第二种方式搭建博客也有很多方法，但主流的有两种： Wordpress GitHub Pages+Hexo 很多人用 Wordpress，为什么我要用 GitHub Pages 来搭建？ 开始我也不知道用哪个，但在网上搜了教程后，发现wordpress比Hexo要麻烦很多。 Hexo是开源在Github上的，而且轻快便捷 GitHub Pages 有 300M 免费空间，资料自己管理，保存可靠。 学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多 顺便看看 GitHub 工作原理，最好的团队协作流程 GitHub 是趋势 概念介绍HEXOHexo 是一个简单、快速、强大的静态博客框架，基于Node.js。由台湾大学生tommy351创建。并把它开源到了Github上，这里是它在Github上的地址：HexoGithub，它主要有以下优点： 极速生成静态页面 一键部署博客 丰富的插件支持 支持 Markdown 更多内容可以查看Hexo的官方文档，建议你只看看介绍部分，其它的你现在也看不太懂。等你搭建好了博客再去详细了解其他的内容就会轻松很多：Hexdocs GitHubGitHub是一个代码托管网站和社交编程网站。这里聚集了世界上各路技术牛叉的大牛，和最优秀的代码库。是全球程序员的天堂。因为是国外的，所以界面全是英文。博主英语过了六级刚开始接触的时候心都突突，不过不要怕，不是还有翻译么， 也有好多人调侃它是全球同性交友平台，其实我不太懂这个梗（女程序员也是很多的好么） GitHub PagesGitHub Pages是用来托管 GitHub 上静态网页的免费站点，其他的不多说。 CodingPages和GithubPages功能相同，其对应的Coding平台也可以实现和Github相似的功能。但没有后者那么出名。是香港的公司，也算是国内的。 看了这些，我相信你一定还是一脸懵逼的。但你可以简单理解成下边的的一段话： 利用Hexo和GithubPages/CodingPages搭建博客，实际上就是利用Hexo在本地（你的电脑上）生成一个博客站点，然后利用网络将它传输到Github/Coding上进行拷贝和备份。再由Github和Coding提供的GithubPages/CodingPages服务将博客部署到网上，这样你的博客就可以作为一个独立的站点被别人浏览（正式上线）。同时你也可以在Github和Coding上管理你的博客。 如果你还想了解更多背景知识，可以看看这篇文章：搭建个人博客，你需要知道这些 搭建过程搭建步骤一般来说，搭建博客有以下几个步骤： 获得个人网站域名 GitHub创建个人仓库 安装Git 安装Node.js 安装Hexo 推送网站 绑定域名 在Coding上部署你的网站 其中，1.7.8你可以不做。但剩下的必须要做，一步都不能少，也不能错。在你看下边推荐的博客的时候，不要忘记看看我下边的建议。 1-7步请看：这篇博客不只前7步，如果你做完了就可以往下做，因为后边的都是属于个性化部分，所以博主在这里没有显示。GitHub+Hexo 搭建个人网站详细教程 第8步请看：这篇博客是在你做完了前7步的基础上做的。hexo干货系列：（四）将hexo博客同时托管到github和coding，这篇博客也讲了怎么在CodingPages部署，可以和上一篇对照着看：我的Hexo博客站的创建历程(一)【Github&amp;Coding双管齐下部署Hexo】 我的建议和踩过的坑 第一篇： 域名建议买.top，比较便宜。当然，土豪随意。 下载Node.js或Git时，由于众所周知的原因，下载速度会很慢。这时你需要看Hexo的官方文档，上边给出了离线下载的地址：Hexdocs 在安装Hexo这一步，hexo init blog及其之后的命令都是在Blog/blog这个目录下进行的，一定要注意，不能弄错了。博主刚开始就是搞错了路径，结果一直报错。。。 在初始化这一步，如果报出了“Please tell me who you are”的错误，要下载Github桌面程序来解决。这样初始化时就会自动弹出登录窗口，直接登录就可以了。又是因为众所周知的原因，官方下载会很慢，所以博主分享了离线版：点击下载 如果你在安装Hexo或者之前的步骤中有报错，建议你重新下载安装。因为这之前的过程全是安装的部分，一旦出错，没有别的原因，一定是你的操作有问题。而且你解决错误的时间一定要比重新安装耗费的时间长。 如果你的域名没有绑定成功，可以参考这篇文章。博主刚开始也是没有绑定成功的，看了这篇文章就成功了：[Hexo个人博客]域名绑定 简明教程（小白篇） 关于Markdown，建议用文中推荐的markdownPad2，下载后预览功能不能使用的问题需要下载插件解决：插件下载，点击这里下载注册码升级专业版：注册码 第二篇： 这里没有踩过坑，很顺利的就配置成功了。 值得一提的是。可以跳过演示这一过程，只要你发布博客的时候能同步到Coding就说明你已经配置成功了。这时在浏览器上输入你的域名/xxx.github.io/xxx.coding.me都会指向你的博客站点。 个性化 终于到了万众瞩目的个性化步骤了，到这里，想必你已经根据博主推荐的链接成功搭建好了博客。 下面来具体说说个性化。 主题选择如果你按照上边搭建博客时推荐的文章那样，选择了next主题。那就不用多说。如果你觉得next主题不符合你的Style，可以参考这篇文章选择你喜欢的主题：Hexo博客主题推荐 但我还是推荐你用next主题，原因： next主题是github上最流行的主题，star和fork的数量远远超过了别的主题。所以相信群众的选择。 next主题的主题配置文件本就内置了许多插件，在个性化的过程中你只需要把flase改成true或者加上对应服务的id就可以直接使用。极为方便。这是其他很多主题没有做到的一点 next主题内部还分为4个主题方案：Muse、Mist、Pisces、Gemini，可以自由选择，更加多元化。我选择的是Pisces。 界面高端大气，配色低调奢华。 ps：如果你没有用next主题，那么以下个性化设置就不用看了。因为它们都是next的配置。 按照主题文档设置选定了主题后，建议先看看主题的文档进行个性化设置。里面是最基本的标签、分类设置，还有第三方服务设置：next主题配置 其他的个性化设置因为用的是next主题，所以这里也是针对于next主题的个性化配置。我博客的所有个性化都是来自这些链接： 网易云音乐链接设置，参考博客搭建时推荐的第一篇博客 这一篇看它的个性化设置部分：Hexo搭建博客教程 RSS和High特效 这篇真的厉害了，有30种特效：hexo的next主题个性化教程:打造炫酷网站 主讲第3方服务：配置第三方服务 这个也很方便，创建新文章后不用再去找了：Hexo添加文章时自动打开编辑器 创建一个菜单页面作为文章目录：hexo下新建页面下如何放多个文章 博客加密：加密插件Github，issue里有解决next主题兼容的方法 上边这些链接里的设置，均为博主亲测有效。从这些链接可以看出，博主也是折腾了很久的。。。 鬼知道我经历了什么 在Github上看issue或者提issue如果你还想折腾，还有两种途径： 可以看看next在Github上的issue：这些都是别人提的，可能会有你想要的设置。如果你遇到了问题，也可以自己提issue。这是网址：next/issues 去Hexo的官方插件页面找，这里的插件很多。只有你想不到，没有你找不到：Hexo插件 我的建议 个性化固然好，但是在设置的时候一定要细心，这些都是要打开代码文件去修改的。建议不要用记事本或写字板打开，可以用VS编辑器打开，不仅方便查错和回退，还便于查找。这里举一个在VS查找的例子： 比如你要设置字数统计功能，你不知道在哪找，但你看到对应的文章中有这样一行:#Post wordcount display settings，你就可以点击右上方的查找图标，输入这行代码，选择全部匹配。就可以定位到你要设置的那部分。 如果你在个性化设置的时候碰到了中文乱码的问题，也可以在VS中点击文件-&gt;高级保存选项-&gt;把编码改成unicodeutf8选项即可 评论功能我推荐来必力和畅言，前者不需要域名备案，直接就可以使用，但界面较丑。后者要进行域名备案才能使用，但界面美观大气，看你怎么选。 关于图床，还是建议用七牛，这也是大多数人的选择，但得到图片外链要4步，很麻烦。网上也有人用插件直接拖拽图片上传得到外链，但好像没有windows平台的。反正我没有找到，麻烦就麻烦一点吧。如果你找到了，可以在下方给我留言。 一定要细心，建议改一项个性化，先不要关闭你改过的文件，在重新生成部署没有错之后在关闭，这样出错了也好改回去。博主有一次就是不知道自己改了啥，结果出错了，幸好根据出错信息定位到了两个文件，然后重新下载了一份干净的next文件作对比，才改过来。所以，一定不要作死。 虽然个性化是可以让你的博客看起来高大上许多，但是不要太过了。忘了自己搭建博客的初心，只有文章才是最重要的，而且太多的个性化会影响博客的加载速度，得不偿失。 The End终于写完啦，如果除了文中博主提到的点。你还有其它问题，可以在评论区留言，我每一条都会回复哦~]]></content>
      <categories>
        <category>学习小记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GithubPages</tag>
        <tag>CodingPages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SecondPage]]></title>
    <url>%2F2017%2F08%2F03%2FSecondPage%2F</url>
    <content type="text"><![CDATA[嗯，我确实不是一个善于起名字的人，但明天的文章绝对不是ThirdPage 先来张美图洗洗眼： 安利一个找图网站，花瓣网：http://huaban.com/。 里面的图片真的挺不错的，插画和风景图都好看。可以定时去洗洗眼٩(๑&gt;◡&lt;๑)۶ ，这可不是广告哦。 说说今天吧，其实早有想法做一个自己的博客，上次在某博客网站发布文章，结果账号一言不合被封杀。。。 当时心里就挺不爽的，随之有了搭建个人博客的想法。 因为太懒了，所以现在才行动。嗯。。。（我是不是承认了什么） 在网上找了很多教程，有WordPress搭建的，还有Hexo和Github，想了想还是后者吧。看着比较简单。 然而不是我太笨，就是我想多了。从昨晚开始搭建博客，中间踩了无数的坑，重构了几次，结果到现在才初见雏形。而且域名还没有绑定成功。。。 内心无比暴躁，伐开森。。 但今天也快完了，就只能到这里了。明天应该就完整的搭建好了吧（是的吧）。 要是明天还不成功，我就，我就，就 ps：我不会承认这是一篇凑个数的文章。。]]></content>
      <categories>
        <category>生活随想</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FirstBlog]]></title>
    <url>%2F2017%2F08%2F03%2FFirstBlog%2F</url>
    <content type="text"><![CDATA[FistPage in my blog. the future is whitin reach.]]></content>
      <categories>
        <category>生活随想</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
